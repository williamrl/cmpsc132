# -*- coding: utf-8 -*-
"""assignment-lists-sortingAndSearching_f22.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Ra4cQV_Fn1TwDr-EzF2VlzM3Pnk752PA
"""



"""### Doubly Linked List

We have previously developed a doubly linked list in an object oriented way. A proper implementation is found below, but feel free to use the code you wrote instead of mine. 

The code needs to be extended to have Class functions that will search for values and also will sort the values.

## Constructing a Doubly Linked List

The **Node** and **Doubly Linked List** class implementations are given:
"""

class Node(object):
    """Doubly linked node which stores an object"""

    def __init__(self, element, next_node=None, previous_node=None):
        # The underscores are to prevent overwriting the variables if inherited and prevents access from outside of scope
        self.__element = element
        self.__next_node = next_node
        self.__previous_node = previous_node

    def get_element(self):
        """Returns the element stored in this node"""
        return self.__element

    def get_previous(self):
        """Returns the previous linked node"""
        return self.__previous_node

    def get_next(self):
        """Returns the next linked node"""
        return self.__next_node

    def set_element(self, element):
        """Sets the element stored in this node"""
        self.__element = element

    def set_previous(self, previous_node):
        """Sets the previous linked node"""
        self.__previous_node = previous_node

    def set_next(self, next_node):
        """Sets the next linked node"""
        self.__next_node = next_node
    
    def __str__(self):
        return str(self.__element)

class DoublyLinkedList(object):
    """Doubly linked node data structure"""

    def __init__(self):
        self.__size = 0
        self.__header = Node('Header')
        self.__trailer = Node('Trailer')
        self.__header.set_next(self.__trailer)
        self.__trailer.set_previous(self.__header)
        self.__current = None

    def __repr__(self):
        if not self.is_empty():
            out = f'('
            for node in self:
                out += f"({node.get_element()}), "
            out = out[:-2]
            out += ')'
        else:
            out = 'Empty List'
        return out
    def __iter__(self):
        self.__current = None
        return self

    def __next__(self):
        """Standard python iterator method"""
        if self.is_empty() or self.__current == self.__trailer:
            raise StopIteration()
        elif self.__current is None:
            self.__current = self.__header
        self.__current = self.__current.get_next()
        if self.__current != self.__trailer:
            return self.__current 
        else:
            raise StopIteration()

    def map(self, function):
        """Run function on every element in the list"""
        for node in self:
            if node != self.__trailer and node != self.__header:
                node.set_element(function(node.get_element()))

    def size(self):
        """Returns the number of elements in the list"""
        return self.__size

    def is_empty(self):
        """Returns the number of elements in the list"""
        return self.__size == 0

    def get_first(self):
        """Get the first element of the list"""
        if self.is_empty():
            raise Exception("List is empty")
        else:
            return self.__header.get_next()

    def get_last(self):
        """Get the last element of the list"""
        if self.is_empty():
            raise Exception("List is empty")
        else:
            return self.__trailer.get_previous()

    def get_previous(self, node):
        """Returns the node before the given node"""
        if node == self.__header:
            raise Exception("Cannot get the element before the header of this list")
        else:
            return node.get_previous()

    def get_next(self, node):
        """Returns the node after the given node"""
        if node == self.__trailer:
            raise Exception("Cannot get the element after the trailer of this list")
        else:
            return node.get_next()

    def add_before(self, new, existing):
        """Insert the new before existing"""
        previous_existing = self.get_previous(existing)
        new.set_previous(previous_existing)
        new.set_next(existing)
        existing.set_previous(new)
        previous_existing.set_next(new)
        self.__size += 1

    def add_after(self, new, existing):
        """Insert the new after existing"""
        next_existing = self.get_next(existing)
        new.set_previous(existing)
        new.set_next(next_existing)
        existing.set_next(new)
        next_existing.set_previous(new)
        self.__size += 1

    def add_first(self, new):
        """Insert the node at the head of the list"""
        self.add_after(new, self.__header)

    def add_last(self, new):
        """Insert the node at the tail of the list"""
        self.add_before(new, self.__trailer)

    def remove(self, node):
        """Removes the given node from the list"""
        before = self.get_previous(node)
        after = self.get_next(node)
        before.set_next(after)
        after.set_previous(before)
        node.set_next(None)
        node.set_previous(None)
        self.__size -= 1

    def sequential_search(self,value):
        """Implementation of a sequential search for a value, also returns the node"""
        current = self.__header
        while current != self.__trailer:
            if current.get_element() == value:
                return current
            current = current.get_next()
        return None

    def binary_search(self,value):
        """Implementation of a binary search for a value, also returns the node"""
        #HINT: REQUIRES THE LIST TO BE SORTED!
        if self.is_empty():
            return None
        else:
            return None
        
    def bubble_sort(self):
        if self.is_empty():
            return None
        else:
            end = None
            while end != self.__header.get_next():
                current = self.__header.get_next()
                while current.get_next() != end:
                    if current.get_element() > current.get_next().get_element():
                        temp = current.get_element()
                        current.set_element(current.get_next().get_element())
                        current.get_next().set_element(temp)
                    current = current.get_next()
                end = current

    def selection_sort(self):
        if self.is_empty():
            return None
        else:
            current = self.__header.get_next()
            while current != self.__trailer:
                min_node = current
                next_node = current.get_next()
                while next_node != self.__trailer:
                    if next_node.get_element() < min_node.get_element():
                        min_node = next_node
                    next_node = next_node.get_next()
                if min_node != current:
                    temp = current.get_element()
                    current.set_element(min_node.get_element())
                    min_node.set_element(temp)
                current = current.get_next()
    
    def insertion_sort(self):
        if self.is_empty():
            return None
        else:
            current = self.__header.get_next().get_next()
            while current != self.__trailer:
                temp = current.get_element()
                previous = current.get_previous()
                while previous != self.__header and previous.get_element() > temp:
                    previous.set_next(Node(previous.get_element(), current, previous.get_previous()))
                    previous = previous.get_previous()
                    previous.get_next().get_next().set_previous(previous.get_next())
                    previous.get_next().set_previous(previous)
                previous.set_next(Node(temp, current, previous))
                current.get_next().set_previous(current.get_previous())
                current.set_previous(previous)
                current = current.get_next()
        
    def shell_sort(self):
        if self.is_empty():
            return None
        else:
            gap = self.__size // 2
            while gap > 0:
                for i in range(gap):
                    self.__sort_sublist(i, gap)
                gap = gap // 2
    
    def merge_sort(self):
        if self.is_empty():
            return
        self.__header.set_next(self.__merge_sort(self.__header.get_next()))
        self.__trailer.set_previous(self.get_last())
    
    def quick_sort(self):
        if self.is_empty():
            return
        self.__quick_sort(self.__header.get_next(), self.__trailer.get_previous())

"""**Task 1 (25 points)**: Implement a sequential search and show the implementation works."""

from numpy import random

dL = DoublyLinkedList()
for i in range(1,21,2):
    dL.add_last(Node(i))
print(dL)

node5 = dL.sequential_search(5)
print(node5)

node12 = dL.sequential_search(12)
print(node12)

#The code below is broken - make it work
node12 = dL.sequential_search(12)
if node12 is not None:
    print(node12)
else:
    print("Node not found")

"""**Task 2 (25 points)**: A Faster Search

A **binary search** should return the node which has a value faster than the above sequential search. 

Implement a **binary search** and run it on the ***Doubly Linked List*** created.

"""

#Test your implementation here
#The code below is broken - make it work
node15= dL.binary_search(15)
print(node15)

"""**Task 4 (50 points)**: Implement the two of the following sorting methods <br>
`Bubble Sort`, `The Selection Sort`, `The Insertion Sort`, `The Shell Sort`,<br>
`The Merge Sort`, or `The Quick Sort`

If you did not like your grade on the previous ** Doubly Linked List** assignment, <br>
I will neglect that grade and count this assignment twice if you successfully implement the `Merge Sort` or `Quick Sort` algorithm(s). 
"""

#Test your implementation here
#do a sort here
dL.first_sort()
for n in dL:
    print(n)

# Reset your list and add in random values again
dL = DoublyLinkedList()

#do a different sort here
dL.second_sort()
for n in dL:
    print(n)

"""**Task -1(Alternative Way to Do this assignment)**: 

Is the Doubly Linked List being a pain and you are having trouble getting the searches and sorts to work? 

If you use a Linked List (singly?) to do all of the above tasks I will also accept this as a proper solution. But you must implement either the '`MERGE SORT` or `QUICK SORT` divide and conquer algos (+10 to do both). 
"""